<!-- Título principal -->
<h1>ToDoList</h1>

<!-- La lista de tareas va PRIMERO -->
<ul id="todo-list">
    <!-- Las tareas se agregarán aquí dinámicamente -->
</ul>

<!-- El contenedor de input y botón de agregar tarea va DESPUÉS de la lista -->
<div id="todo-input-container">
    <input type="text" id="new-todo-input" placeholder="Agregar nueva tarea">
    <!-- Botón Agregar Tarea (cambiado a '+') -->
    <button id="add-todo-button" aria-label="Agregar Tarea">+</button>
</div>

<!-- Botón para reordenar (icono) -->
<button id="reorder-button" aria-label="Reordenar tareas por prioridad">↕</button>

<!-- Sección para Importar/Exportar datos -->
<div id="data-management">
    <button id="export-data-button" aria-label="Exportar datos">Exportar</button>
    <button id="import-data-button" aria-label="Importar datos">Importar</button>
    <!-- Input de archivo oculto para la importación -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">
</div>


<!-- Botón para alternar modo oscuro/claro (icono) -->
<button id="dark-mode-toggle" aria-label="Alternar modo oscuro/claro">◑</button> <!-- Símbolo de luna -->


<script>
    // Obtener referencias a los elementos del DOM
    const todoInput = document.getElementById('new-todo-input');
    const addTodoButton = document.getElementById('add-todo-button');
    const todoListContainer = document.getElementById('todo-list');
    const reorderButton = document.getElementById('reorder-button'); // Referencia al botón de reordenar
    const darkModeToggle = document.getElementById('dark-mode-toggle'); // Referencia al nuevo botón de dark mode
    const body = document.body; // Referencia al body para alternar la clase

    // Referencias a los nuevos elementos de gestión de datos
    const exportDataButton = document.getElementById('export-data-button');
    const importDataButton = document.getElementById('import-data-button');
    const importFileInput = document.getElementById('import-file-input');


    // Colores de prioridad disponibles y su orden para ciclar
    const PRIORITY_COLORS = ['none', 'red', 'orange', 'yellow', 'green'];

    // Definir el orden numérico para la clasificación de prioridad
    const PRIORITY_ORDER = {
        'red': 1,
        'orange': 2,
        'yellow': 3,
        'green': 4,
        'none': 5 // Las tareas sin color van al final
    };


    // --- Funciones para Local Storage ---

    // ORIGINAL saveTodos - THIS WILL BE OVERWRITTEN BY THE FIREBASE SCRIPT
    // function saveTodos(todosArray) {
    //     try {
    //         // console.log("Guardando todos:", JSON.stringify(todosArray)); // Diagnóstico
    //         localStorage.setItem('todos', JSON.stringify(todosArray));
    //     } catch (e) {
    //         console.error("Error al guardar en localStorage:", e);
    //         // Opcional: mostrar un mensaje al usuario
    //         // alert("No se pudo guardar la lista de tareas.");
    //     }
    // }

    // Keep loadTodos as the Firebase script uses it to mirror data locally
    function loadTodos() {
        try {
            const storedTodos = localStorage.getItem('todos');
            // console.log("Cargando de localStorage:", storedTodos); // Diagnóstico
            if (storedTodos) {
                const todos = JSON.parse(storedTodos);
                // Asegurarse de que las tareas antiguas tengan las propiedades necesarias
                // y limpiar datos potencialmente corruptos o faltantes
                return todos.map(todo => ({
                    text: todo.text || 'Tarea sin nombre', // Default text if missing
                    completed: typeof todo.completed === 'boolean' ? todo.completed : false, // Ensure boolean
                    subtasks: Array.isArray(todo.subtasks) ? todo.subtasks.map(sub => ({
                        text: sub.text || 'Sub-tarea sin nombre', // Default text
                        completed: typeof sub.completed === 'boolean' ? sub.completed : false // Ensure boolean
                    })) : [], // Ensure subtasks is an array and clean its items
                    showSubtaskUI: typeof todo.showSubtaskUI === 'boolean' ? todo.showSubtaskUI : false, // Ensure boolean with default false
                    priorityColor: PRIORITY_COLORS.includes(todo.priorityColor) ? todo.priorityColor : 'none', // Ensure valid color with default 'none'
                    date: typeof todo.date === 'string' && todo.date.match(/^\d{4}-\d{2}-\d{2}$/) ? todo.date : null // Add date property, validate format
                }));
            } else {
                return [];
            }
        } catch (e) {
             console.error("Error al cargar de localStorage:", e);
             // Opcional: notificar al usuario sobre datos corruptos
             alert("Error al cargar la lista de tareas. Se iniciará una nueva lista.");
             return []; // Si hay error, empezar con lista vacía
        }
    }

    // --- Funciones de Lógica de la App ---

    // Calcula el progreso de una tarea principal basado en sus sub-tareas
    function calculateProgress(subtasks) {
        if (!subtasks || subtasks.length === 0) {
            return 0; // 0% si no hay sub-tareas
        }
        const completed = subtasks.filter(sub => sub.completed).length;
        return (completed / subtasks.length) * 100;
    }

    // --- Functions for Creating DOM Elements ---
    // Centralize the creation of recurring elements for consistency

    function createMainTaskHeader(mainTask, mainIndex) {
        const mainTaskHeader = document.createElement('div');
        mainTaskHeader.classList.add('main-task-header');

        const mainCheckbox = document.createElement('input');
        mainCheckbox.type = 'checkbox';
        mainCheckbox.checked = mainTask.completed;
        // El listener ahora solo llama a toggleMainCompletion, que guarda y renderiza SIN reordenar
        mainCheckbox.addEventListener('change', (event) => {
            toggleMainCompletion(mainIndex, event.target.checked);
        });

        const priorityLabel = document.createElement('div');
        priorityLabel.classList.add('priority-color-label');
        priorityLabel.dataset.color = mainTask.priorityColor;
        priorityLabel.title = `Prioridad: ${mainTask.priorityColor.charAt(0).toUpperCase() + mainTask.priorityColor.slice(1)}`;
        // El listener ahora solo llama a cyclePriorityColor, que guarda y renderiza SIN reordenar
        priorityLabel.addEventListener('click', () => {
            cyclePriorityColor(mainIndex);
        });

        const mainTaskSpan = document.createElement('span');
        mainTaskSpan.textContent = mainTask.text;

        // --- Nuevo: Input de Fecha ---
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.classList.add('task-date-input');
        dateInput.value = mainTask.date || ''; // Usar el valor de la tarea o cadena vacía si es null
        dateInput.title = 'Establecer fecha'; // Tooltip
        // Listener para guardar la fecha cuando cambia
        dateInput.addEventListener('change', (event) => {
            updateTaskDate(mainIndex, event.target.value);
        });


        const deleteMainButton = document.createElement('button');
        deleteMainButton.textContent = '-'; // Cambiado a '-'
        deleteMainButton.setAttribute('aria-label', 'Eliminar tarea'); // Añadir para accesibilidad

        // El listener ahora solo llama a deleteTodo, que guarda y renderiza SIN reordenar
        deleteMainButton.addEventListener('click', () => {
             if ((mainTask.subtasks && mainTask.subtasks.length > 0) || mainTask.completed) {
                 if (!confirm(`¿Estás seguro de eliminar la tarea "${mainTask.text}"?`)) {
                     return;
                 }
             }
            deleteTodo(mainIndex);
        });

        mainTaskHeader.appendChild(mainCheckbox);
        mainTaskHeader.appendChild(priorityLabel);
        mainTaskHeader.appendChild(mainTaskSpan);
        mainTaskHeader.appendChild(dateInput); // Añadir el input de fecha
        mainTaskHeader.appendChild(deleteMainButton);

        return mainTaskHeader;
    }

    function createProgressBar(mainTask) {
         const progressContainer = document.createElement('div');
         progressContainer.classList.add('progress-container');

         const progressBar = document.createElement('div');
         progressBar.classList.add('progress-bar');

         let progressPercentage = 0;
         if (mainTask.subtasks && mainTask.subtasks.length > 0) {
             progressPercentage = calculateProgress(mainTask.subtasks);
         } else if (mainTask.completed && (!mainTask.subtasks || mainTask.subtasks.length === 0)) {
             progressPercentage = 100;
         }
         progressBar.style.width = `${progressPercentage}%`;

         // Texto de progreso oculto por CSS
         // const progressText = document.createElement('div');
         // progressText.classList.add('progress-text');
         // progressText.textContent = `${Math.round(progressPercentage)}%`;

         progressContainer.appendChild(progressBar);
         // progressContainer.appendChild(progressText);

         return progressContainer;
    }

    function createAddSubtasksToggle(mainIndex) {
         const addSubtasksToggle = document.createElement('button');
         addSubtasksToggle.classList.add('add-subtasks-toggle'); // Ya usa el estilo de botón de añadir discreto
         addSubtasksToggle.textContent = '+'; // Cambiado a '+'
         addSubtasksToggle.setAttribute('aria-label', 'Mostrar/Ocultar sección de sub-tareas'); // Añadir para accesibilidad

         // El listener ahora solo llama a toggleSubtaskSection, que guarda y renderiza SIN reordenar
         addSubtasksToggle.addEventListener('click', () => {
             toggleSubtaskSection(mainIndex, true);
         });
         return addSubtasksToggle;
    }

    function createSubtasksList(mainTask, mainIndex) {
        const subtasksList = document.createElement('ul');
        subtasksList.classList.add('subtasks-list');

        if (mainTask.subtasks && mainTask.subtasks.length > 0) {
            mainTask.subtasks.forEach((subtask, subIndex) => {
                const subtaskItem = document.createElement('li');

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = subtask.completed;
                // El listener ahora solo llama a toggleSubtaskCompletion, que guarda y renderiza SIN reordenar
                checkbox.addEventListener('change', () => {
                    toggleSubtaskCompletion(mainIndex, subIndex);
                });

                const subtaskSpan = document.createElement('span');
                subtaskSpan.textContent = subtask.text;

                const deleteSubtaskButton = document.createElement('button');
                deleteSubtaskButton.textContent = '-'; // Cambiado a '-'
                deleteSubtaskButton.setAttribute('aria-label', 'Eliminar sub-tarea'); // Añadir para accesibilidad

                // El listener ahora solo llama a deleteSubtask, que guarda y renderiza SIN reordenar
                deleteSubtaskButton.addEventListener('click', () => {
                    deleteSubtask(mainIndex, subIndex);
                });

                subtaskItem.appendChild(checkbox);
                subtaskItem.appendChild(subtaskSpan);
                subtaskItem.appendChild(deleteSubtaskButton);
                subtasksList.appendChild(subtaskItem); // CORRECTO: Adjuntar el item a la lista de sub-tareas
            });
        }
        return subtasksList;
    }

    function createSubtaskInputContainer(mainIndex) {
         const subtaskInputContainer = document.createElement('div');
         subtaskInputContainer.classList.add('subtask-input-container'); // Ya usa display: flex y align-items: center;

         const subtaskInput = document.createElement('input');
         subtaskInput.type = 'text';
         subtaskInput.placeholder = 'Agregar nueva sub-tarea...';
         // subtaskInput ya usa el estilo unificado para inputs de añadir

         const addSubtaskButton = document.createElement('button');
         addSubtaskButton.textContent = '+'; // Cambiado a '+'
         addSubtaskButton.setAttribute('aria-label', 'Agregar sub-tarea'); // Añadir para accesibilidad

         // addSubtaskButton ya usa el estilo unificado para botones de añadir
         // No necesita margin-left: auto aquí, ya que el contenedor es flex y el input tiene flex-grow: 1

         // El listener ahora solo llama a addSubtask, que guarda y renderiza SIN reordenar
         addSubtaskButton.addEventListener('click', () => {
             addSubtask(mainIndex, subtaskInput);
         });
          subtaskInput.addEventListener('keypress', (event) => {
              if (event.key === 'Enter') {
                  event.preventDefault();
                  addSubtaskButton.click();
              }
          });

         subtaskInputContainer.appendChild(subtaskInput);
         subtaskInputContainer.appendChild(addSubtaskButton);

         return subtaskInputContainer;
    }


    // Función para renderizar (mostrar) la lista completa de tareas en el HTML
    // Esta función AHORA SOLO RENDERIZA el array que recibe, NO LO ORDENA.
    // It is used by both the original script and the new Firebase script.
    function renderTodos(todosArray) {
        // console.log("Renderizando todos:", todosArray); // Diagnóstico

        // --- Lógica de Ordenación por Prioridad ELIMINADA de aquí ---
        // todosArray.sort((a, b) => { ... });
        // --- Fin Lógica de Ordenación ELIMINADA ---


        todoListContainer.innerHTML = ''; // Limpiar la lista actual

        if (todosArray.length === 0) {
            // CSS se encarga del mensaje de lista vacía
            // Limpiar el input de agregar tarea principal por si acaso estaba lleno
            todoInput.value = '';
            return;
        }

        // Usamos el array tal cual está (ya sea el cargado, el modificado, o el ordenado por el botón)
        todosArray.forEach((mainTask, mainIndex) => {
            const listItem = document.createElement('li');
            listItem.classList.add('todo-item');
            // console.log(`Tarea ${mainIndex} (${mainTask.text}): Completed=${mainTask.completed}, ShowSubtaskUI=${mainTask.showSubtaskUI}, Priority=${mainTask.priorityColor}, Date=${mainTask.date}, Subtasks=${mainTask.subtasks.length}`); // Diagnóstico

            // Añadir clases CSS según el estado
            if (mainTask.completed) {
                listItem.classList.add('completed');
            }
             // Añadir la clase para controlar la visibilidad de la sección de sub-tareas
             if (mainTask.showSubtaskUI) {
                listItem.classList.add('show-subtask-ui');
             }

            // Agregar los elementos a la tarea principal (li) en el orden deseado
            listItem.appendChild(createMainTaskHeader(mainTask, mainIndex));
            listItem.appendChild(createProgressBar(mainTask));
            listItem.appendChild(createAddSubtasksToggle(mainIndex)); // Botón para activar sub-tareas (ahora solo '+')
            listItem.appendChild(createSubtasksList(mainTask, mainIndex)); // Lista de sub-tareas
            listItem.appendChild(createSubtaskInputContainer(mainIndex)); // Input/Button para añadir sub-tarea (ahora solo '+')

            // Agregar el elemento de lista principal a la lista principal en el HTML
            todoListContainer.appendChild(listItem);

             // Enfocar el input de sub-tarea si se acaba de mostrar la sección
             // Solo si la sección DEBE estar visible y no hay sub-tareas iniciales.
             // La lógica de encontrar el elemento por índice ahora es más fiable
             // porque renderTodos no reordena automáticamente.
             if (mainTask.showSubtaskUI && (mainTask.subtasks === undefined || mainTask.subtasks.length === 0)) {
                 setTimeout(() => {
                    // Encontrar el elemento de lista recién creado usando el índice del array
                    const listItemElement = todoListContainer.children[mainIndex];
                    if (listItemElement) {
                        const inputElement = listItemElement.querySelector('.subtask-input-container input[type="text"]');
                        if (inputElement) {
                            // console.log("Intentando enfocar input de sub-tarea..."); // Diagnóstico
                            inputElement.focus();
                        } else {
                            // console.log("Input de sub-tarea no encontrado para enfocar."); // Diagnóstico
                        }
                    }
                 }, 50); // Un pequeño retraso (ej. 50ms) puede ayudar
             }
        });
         // Limpiar el input de agregar tarea principal después de renderizar la lista
         todoInput.value = '';
    }

     // --- Funciones de Manipulación de Datos y Lógica de Completado ---

    // Función para mostrar/ocultar la sección de sub-tareas para una tarea principal
    function toggleSubtaskSection(mainTaskIndex, show) {
        // console.log(`toggleSubtaskSection: Tarea ${mainTaskIndex}, Show: ${show}`); // Diagnóstico
        const todos = loadTodos();
        if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
            const mainTask = todos[mainTaskIndex];
            mainTask.showSubtaskUI = show;
            // Si se muestra la sección, inicializa el array de sub-tareas si es null/undefined
            if (show && (!Array.isArray(mainTask.subtasks) || mainTask.subtasks.length === 0)) {
                 mainTask.subtasks = []; // Asegurarse de que es un array vacío si se muestra y no tiene subs
            }

            saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
            renderTodos(todos); // Renderiza el estado actual SIN reordenar
        } else {
             console.error("Índice de tarea principal inválido para toggleSubtaskSection:", mainTaskIndex);
        }
    }

    // Función para ciclar el color de prioridad de una tarea principal
    function cyclePriorityColor(mainTaskIndex) {
         // console.log(`Ciclando color para tarea ${mainTaskIndex}`); // Diagnóstico
         const todos = loadTodos();
         if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
             const currentColors = PRIORITY_COLORS; // ['none', 'red', 'orange', 'yellow', 'green']
             // Asegurar que priorityColor es un string válido antes de buscar el índice
             const currentColor = typeof todos[mainTaskIndex].priorityColor === 'string'
                                  ? todos[mainTaskIndex].priorityColor
                                  : 'none'; // Usar 'none' if it's null, undefined, or not a string
             const currentIndex = currentColors.indexOf(currentColor);
             const nextIndex = (currentIndex + 1) % currentColors.length; // Ciclar al siguiente
             todos[mainTaskIndex].priorityColor = currentColors[nextIndex];
             // console.log(`Nuevo color para tarea ${mainTaskIndex}: ${todos[mainIndex].priorityColor}`); // Diagnóstico

             saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
             renderTodos(todos); // Renderiza el estado actual SIN reordenar
         } else {
              console.error("Índice de tarea principal inválido para ciclar color:", mainTaskIndex);
         }
    }

    // --- Nuevo: Función para actualizar la fecha de una tarea principal ---
    function updateTaskDate(mainTaskIndex, newDateValue) {
        // console.log(`Actualizando fecha para tarea ${mainTaskIndex} a ${newDateValue}`); // Diagnóstico
        const todos = loadTodos();
        if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
            // Guardar null si el valor está vacío (el usuario borró la fecha)
            todos[mainTaskIndex].date = newDateValue || null;

            saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
            renderTodos(todos); // Renderiza el estado actual SIN reordenar
            // console.log("Fecha de tarea actualizada:", todos[mainTaskIndex]); // Diagnóstico
        } else {
             console.error("Índice de tarea principal inválido para actualizar fecha:", mainTaskIndex);
        }
    }


    // Función para agregar una nueva tarea principal
    function addTodo() {
        const newTodoText = todoInput.value.trim();

        if (newTodoText === '') {
            alert('Por favor, ingresa el nombre de la tarea.');
            return;
        }

        const todos = loadTodos();

        todos.push({
            text: newTodoText,
            completed: false,
            subtasks: [], // Siempre array vacío inicialmente
            showSubtaskUI: false, // Sección de sub-tareas oculta inicialmente
            priorityColor: 'none', // Color de prioridad por defecto
            date: null // --- Nuevo: Fecha inicialmente nula ---
        });

        saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
        renderTodos(todos); // Renderiza el estado actual SIN reordenar
        // Limpiar el input de agregar tarea principal aquí también para consistencia
        todoInput.value = '';
        // console.log("Tarea principal agregada:", todos); // Diagnóstico
    }

    // Función para agregar una sub-tarea a una tarea principal específica
    function addSubtask(mainTaskIndex, subtaskInput) {
         const newSubtaskText = subtaskInput.value.trim();

         if (newSubtaskText === '') {
             alert('Por favor, ingresa el nombre de la sub-tarea.');
             // console.log(`No se agregó sub-tarea a tarea ${mainTaskIndex}: texto vacío.`); // Diagnóstico
             return;
         }
         // console.log(`Agregando sub-tarea "${newSubtaskText}" a tarea ${mainTaskIndex}`); // Diagnóstico

         const todos = loadTodos();

         if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
             const mainTask = todos[mainTaskIndex];

             // Asegurarse de que subtasks es un array antes de pushear
             if (!Array.isArray(mainTask.subtasks)) {
                 mainTask.subtasks = [];
             }

             mainTask.subtasks.push({
                 text: newSubtaskText,
                 completed: false
             });

             // Al añadir una sub-tarea, la tarea principal ya no puede considerarse "completada"
             // si ahora tiene sub-tareas pendientes. Desmarcamos si estaba marcada.
             if (mainTask.completed) {
                 mainTask.completed = false;
             }

             // Asegurarse de que la sección de sub-tareas está visible (ya debería estarlo al llegar aquí)
             mainTask.showSubtaskUI = true; // Redundante si se llama desde el input de sub-tarea, but safe.

             saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
             renderTodos(todos); // Renderiza el estado actual SIN reordenar

             // Limpiar el input y enfocarlo
             subtaskInput.value = '';
             // console.log("Sub-tarea agregada y renderizada. Intentando enfocar input."); // Diagnóstico
             // Usamos el índice original ya que renderTodos no reordena automáticamente
             const listItemElement = todoListContainer.children[mainTaskIndex];
             if (listItemElement) {
                 const inputElement = listItemElement.querySelector('.subtask-input-container input[type="text"]');
                 if (inputElement) {
                     setTimeout(() => { inputElement.focus(); }, 50); // Pequeño retraso para asegurar que el DOM esté listo
                 }
             }


         } else {
             console.error("Índice de tarea principal inválido para agregar sub-tarea:", mainTaskIndex);
         }
    }

    // Función para eliminar una tarea principal
    function deleteTodo(indexToDelete) {
        // console.log(`Eliminando tarea principal ${indexToDelete}`); // Diagnóstico
        const todos = loadTodos();

        if (indexToDelete >= 0 && indexToDelete < todos.length) {
            todos.splice(indexToDelete, 1);

            saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
            renderTodos(todos); // Renderiza el estado actual SIN reordenar
            // console.log("Tarea principal eliminada:", todos); // Diagnóstico
        } else {
            console.error("Índice de tarea principal a eliminar fuera de rango:", indexToDelete);
        }
    }

    // Función para eliminar una sub-tarea
    function deleteSubtask(mainTaskIndex, subtaskIndexToDelete) {
         // console.log(`Eliminando sub-tarea ${subtaskIndexToDelete} de tarea principal ${mainTaskIndex}`); // Diagnóstico
         const todos = loadTodos();

         if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
             const mainTask = todos[mainTaskIndex];
             if (Array.isArray(mainTask.subtasks) && subtaskIndexToDelete >= 0 && subtaskIndexToDelete < mainTask.subtasks.length) {
                 mainTask.subtasks.splice(subtaskIndexToDelete, 1);

                 // Después de eliminar, recalcular el estado de completado de la tarea principal
                 const allSubtasksCompleted = mainTask.subtasks.length > 0 && mainTask.subtasks.every(sub => sub.completed);

                 if (mainTask.subtasks.length === 0) {
                     // Si no quedan sub-tareas, desmarcar la principal y ocultar la sección de sub-tareas
                     mainTask.completed = false;
                     mainTask.showSubtaskUI = false; // Ocultar sección si no hay subs
                 } else {
                     // Si aún quedan sub-tareas, actualizar el estado principal si es necesario
                     mainTask.completed = allSubtasksCompleted;
                 }

                 saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
                 renderTodos(todos); // Renderiza el estado actual SIN reordenar
                 // console.log("Sub-tarea eliminada. Tarea principal actualizada:", mainTask); // Diagnóstico
             } else {
                 console.error("Índice de sub-tarea a eliminar fuera de rango:", subtaskIndexToDelete);
             }
         } else {
              console.error("Índice de tarea principal inválido para eliminar sub-tarea:", mainTaskIndex);
         }
    }

    // Función para cambiar el estado de completado de una sub-tarea
    function toggleSubtaskCompletion(mainTaskIndex, subtaskIndexToToggle) {
         // console.log(`Cambiando estado de sub-tarea ${subtaskIndexToToggle} en tarea principal ${mainTaskIndex}`); // Diagnóstico
         const todos = loadTodos();

         if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
             const mainTask = todos[mainTaskIndex];
              if (Array.isArray(mainTask.subtasks) && subtaskIndexToToggle >= 0 && subtaskIndexToToggle < mainTask.subtasks.length) {
                 mainTask.subtasks[subtaskIndexToToggle].completed = !mainTask.subtasks[subtaskIndexToToggle].completed;

                 // Recalcular si todas las sub-tareas están completadas
                 const allSubtasksCompleted = mainTask.subtasks.length > 0 && mainTask.subtasks.every(sub => sub.completed);

                 // Auto-marca/desmarca la tarea principal if THERE ARE subtasks
                 if (mainTask.subtasks.length > 0) {
                      mainTask.completed = allSubtasksCompleted;
                 }
                 // If it has no subtasks, the main checkbox is controlled manually.


                 saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
                 renderTodos(todos); // Renderiza el estado actual SIN reordenar
                 // console.log("Estado sub-tarea cambiado. Tarea principal actualizada:", mainTask); // Diagnóstico
             } else {
                 console.error("Índice de sub-tarea a cambiar estado fuera de rango:", subtaskIndexToToggle);
             }
         } else {
             console.error("Índice de tarea principal inválido para cambiar estado de sub-tarea:", mainTaskIndex);
         }
    }

     // Función para cambiar el estado de completado de la TAREA PRINCIPAL
    function toggleMainCompletion(mainTaskIndex, isChecked) {
         // console.log(`Cambiando estado de tarea principal ${mainTaskIndex} a ${isChecked}`); // Diagnóstico
         const todos = loadTodos();

         if (mainTaskIndex >= 0 && mainTaskIndex < todos.length) {
             const mainTask = todos[mainTaskIndex];

             mainTask.completed = isChecked;

             // Si la tarea principal tiene sub-tareas, sincronizar el estado de sus sub-tareas
             if (Array.isArray(mainTask.subtasks) && mainTask.subtasks.length > 0) {
                 mainTask.subtasks.forEach(subtask => {
                     subtask.completed = isChecked;
                 });
             }
             // Si no tiene sub-tareas, solo se actualiza el estado principal.


             saveTodos(todos); // Use the global saveTodos (now modified by Firebase script)
             renderTodos(todos); // Renderiza el estado actual SIN reordenar
             // console.log("Estado tarea principal cambiado:", mainTask); // Diagnóstico
         } else {
              console.error("Índice de tarea principal inválido para cambiar estado:", mainTaskIndex);
         }
    }

    // --- Dark Mode Toggle Functionality ---
    function enableDarkMode() {
        body.classList.add('dark-mode');
        localStorage.setItem('theme', 'dark');
        darkModeToggle.innerHTML = '☀'; // Usar innerHTML para el símbolo de sol
        darkModeToggle.setAttribute('aria-label', 'Alternar a modo claro');
    }

    function disableDarkMode() {
        body.classList.remove('dark-mode');
        localStorage.setItem('theme', 'light');
         darkModeToggle.innerHTML = '◑'; // Usar innerHTML para el símbolo de luna
         darkModeToggle.setAttribute('aria-label', 'Alternar a modo oscuro');
    }

    function toggleDarkMode() {
        if (body.classList.contains('dark-mode')) {
            disableDarkMode();
        } else {
            enableDarkMode();
        }
    }

    // --- Funciones de Importación/Exportación ---
    // Keep these as they operate on the *current* state, which is kept in sync with Firebase by saveTodos

    // Función para exportar los datos a un archivo JSON
    function exportData() {
        try {
            const todos = loadTodos(); // Cargar los datos actuales (desde localStorage, which is a mirror)
            const dataStr = JSON.stringify(todos, null, 2); // Convertir a JSON con formato legible
            const blob = new Blob([dataStr], { type: 'application/json' }); // Crear un Blob
            const url = URL.createObjectURL(blob); // Crear una URL para el Blob

            const a = document.createElement('a'); // Crear un enlace temporal
            a.href = url;
            // Generar un nombre de archivo con la fecha actual
            const date = new Date().toISOString().split('T')[0]; // Formato YYYY-MM-DD
            a.download = `todolist_export_${date}.json`; // Nombre del archivo

            // Simular un clic en el enlace para iniciar la descarga
            document.body.appendChild(a); // Necesario para Firefox
            a.click();

            // Limpiar después de la descarga
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Liberar la URL del Blob

            console.log("Datos exportados correctamente.");
            // Opcional: Mostrar un mensaje discreto al usuario
            // alert("Datos exportados correctamente.");

        } catch (e) {
            console.error("Error al exportar datos:", e);
            alert("Error al exportar los datos.");
        }
    }

    // Función para manejar la selección del archivo de importación
    function handleFileSelect(event) {
        const file = event.target.files[0]; // Obtener el primer archivo seleccionado

        if (!file) {
            return; // No se seleccionó ningún archivo
        }

        const reader = new FileReader(); // Crear un lector de archivos

        // Cuando el archivo se haya leído
        reader.onload = (event) => {
            try {
                const fileContent = event.target.result;
                const parsedData = JSON.parse(fileContent); // Parsear el contenido JSON

                // Validación básica: Asegurarse de que es un array
                if (!Array.isArray(parsedData)) {
                    alert("El archivo seleccionado no contiene un formato de lista válido.");
                    console.error("Datos importados no son un array:", parsedData);
                    return;
                }

                // Clean and validate the imported data structure (same logic as loadTodos)
                const cleanedData = parsedData.map(todo => ({
                    text: todo.text || 'Tarea sin nombre',
                    completed: typeof todo.completed === 'boolean' ? todo.completed : false,
                    subtasks: Array.isArray(todo.subtasks) ? todo.subtasks.map(sub => ({
                        text: sub.text || 'Sub-tarea sin nombre',
                        completed: typeof sub.completed === 'boolean' ? sub.completed : false
                    })) : [],
                    showSubtaskUI: typeof todo.showSubtaskUI === 'boolean' ? todo.showSubtaskUI : false,
                    priorityColor: PRIORITY_COLORS.includes(todo.priorityColor) ? todo.priorityColor : 'none',
                    date: typeof todo.date === 'string' && todo.date.match(/^\d{4}-\d{2}-\d{2}$/) ? todo.date : null // Validate imported date
                }));


                // Opcional: Confirmar al usuario antes de sobrescribir
                // Note: This check uses loadTodos(), which will load from localStorage (the mirror)
                if (loadTodos().length > 0) { // Only if there are already tasks
                     if (!confirm("¿Estás seguro de importar los datos? Esto reemplazará tu lista actual.")) {
                         return; // Cancel if user doesn't confirm
                     }
                }

                // Save the imported data. This will use the OVERWRITTEN saveTodos
                // which saves to both localStorage and Firebase.
                saveTodos(cleanedData);
                renderTodos(cleanedData); // Render the list with imported data
                alert("Datos importados correctamente.");
                console.log("Datos importados and rendered.");

            } catch (e) {
                console.error("Error al processar el archivo importado:", e);
                alert("Error al leer o procesar el archivo. Asegúrate de que sea un archivo JSON válido.");
            } finally {
                // Clear the value of the file input so that the 'change' event fires
                // if the same file is selected again.
                importFileInput.value = '';
            }
        };

        // Handle file read errors
        reader.onerror = (event) => {
            console.error("Error al leer el archivo:", event.target.error);
            alert("Error al leer el archivo.");
             importFileInput.value = ''; // Clear input in case of error
        };

        reader.readAsText(file); // Read the file as text
    }


    // --- Event Listeners Globales ---

    addTodoButton.addEventListener('click', addTodo);

    todoInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault();
            addTodo();
        }
    });

    // --- Event Listener para el botón de Reordenar ---
    reorderButton.addEventListener('click', () => {
        const todos = loadTodos(); // Cargar el estado actual (desde localStorage)
        // Aplicar la lógica de ordenación
        todos.sort((a, b) => {
            const rankA = PRIORITY_ORDER[a.priorityColor] || PRIORITY_ORDER['none'];
            const rankB = PRIORITY_ORDER[b.priorityColor] || PRIORITY_ORDER['none'];

            // --- Nuevo: Ordenar por fecha después de prioridad ---
            // Si las prioridades son iguales, ordenar por fecha.
            // Tareas con fecha van antes que tareas sin fecha.
            // Entre tareas con fecha, ordenar cronológicamente.
            if (rankA === rankB) {
                const dateA = a.date ? new Date(a.date).getTime() : Infinity; // Infinity para que las sin fecha vayan al final
                const dateB = b.date ? new Date(b.date).getTime() : Infinity;
                return dateA - dateB;
            }

            return rankA - rankB; // Orden ascendente por rank (menor rank = mayor prioridad)
        });
        saveTodos(todos); // Guardar el array ya ordenado (uses the overwritten function -> localStorage + Firebase)
        renderTodos(todos); // Renderizar la lista en el nuevo orden
        // console.log("Lista reordenada por prioridad y fecha:", todos); // Diagnóstico
    });

    // --- Event Listener para el botón de Dark Mode ---
    darkModeToggle.addEventListener('click', toggleDarkMode);

    // --- Event Listeners para Importar/Exportar ---
    exportDataButton.addEventListener('click', exportData);

    // El botón de importar solo simula un clic en el input de archivo oculto
    importDataButton.addEventListener('click', () => {
        importFileInput.click();
    });

    // El input de archivo real escucha el evento 'change'
    importFileInput.addEventListener('change', handleFileSelect);


    // --- Inicialización ---

    // ORIGINAL DOMContentLoaded - THE LOADING PART WILL BE HANDLED BY THE FIREBASE SCRIPT
    document.addEventListener('DOMContentLoaded', () => {
        // console.log("DOM cargado. Inicializando..."); // Diagnóstico

        // Load the theme preference at the start (keep this part)
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            enableDarkMode(); // Apply dark mode if it was saved
        } else {
            disableDarkMode(); // Ensure light mode if no preference or it's 'light'
        }

        // --- Original loading logic commented out ---
        // const initialTodos = loadTodos();
        // renderTodos(initialTodos); // Render the initial list (in the order it was saved)
    });

</script>

<!-- Firebase Firestore (sin autenticación, solo para uso privado) -->
<!-- IMPORTANT: This script must be type="module" and placed AFTER the main script -->
<script type="module">
  // 1. Importar los módulos necesarios
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.0/firebase-app.js";
  import { getFirestore, collection, getDocs, addDoc, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/11.7.0/firebase-firestore.js";

  // 2. Configurar tu conexión a Firebase (esto lo copiaste desde Firebase)
  const firebaseConfig = {
    apiKey: "AIzaSyBUZK_BB9XrII8WXabhF2kiyphS1VVMVH4",
    authDomain: "todolist-5cc91.firebaseapp.com",
    projectId: "todolist-5cc91",
    storageBucket: "todolist-5cc91.firebasestorage.app",
    messagingSenderId: "834516228026",
    appId: "1:834516228026:web:772d2e3a6fbe958a212f83"
  };

  // 3. Inicializar Firebase y obtener acceso a Firestore
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const tareasRef = collection(db, "tareas");

  // 4. Función para guardar TODAS las tareas en Firestore
  // This function is ASYNC because it interacts with Firebase
  async function saveTodosOnline(todosArray) {
    console.log("Saving todos to Firestore...");
    try {
        // Fetch all current documents in the collection
        const querySnapshot = await getDocs(tareasRef);
        const deletePromises = [];
        // Delete them
        querySnapshot.forEach(docSnap => {
          deletePromises.push(deleteDoc(doc(db, "tareas", docSnap.id)));
        });
        await Promise.all(deletePromises); // Wait for all deletions to complete
        console.log("Previous todos cleared from Firestore.");

        // Add the new todos
        const addPromises = [];
        for (const todo of todosArray) {
          // Firestore does not store 'undefined', so clean the object
          const cleanedTodo = JSON.parse(JSON.stringify(todo)); // Simple way to remove undefined
          addPromises.push(addDoc(tareasRef, cleanedTodo));
        }
        await Promise.all(addPromises); // Wait for all additions to complete
        console.log(`Successfully saved ${todosArray.length} todos to Firestore.`);
    } catch (e) {
        console.error("Error saving todos to Firestore:", e);
        // Optional: Notify user? This runs on every save, maybe too noisy.
    }
  }

  // 5. Función para cargar las tareas desde Firestore
  // This function is ASYNC because it interacts with Firebase
  async function loadTodosOnline() {
    console.log("Attempting to load todos from Firestore...");
    try {
        const querySnapshot = await getDocs(tareasRef);
        const todos = [];
        querySnapshot.forEach(docSnap => {
          todos.push(docSnap.data());
        });
         console.log(`Loaded ${todos.length} todos from Firestore.`);

        // ALSO save them to localStorage, mirroring the online state
        localStorage.setItem('todos', JSON.stringify(todos));
         console.log("Also saved loaded todos to localStorage.");

        // Clean/validate the loaded data structure before returning,
        // using the same logic as the original loadTodos
         const cleanedTodos = todos.map(todo => ({
            text: todo.text || 'Tarea sin nombre', // Default text if missing
            completed: typeof todo.completed === 'boolean' ? todo.completed : false, // Ensure boolean
            subtasks: Array.isArray(todo.subtasks) ? todo.subtasks.map(sub => ({
                text: sub.text || 'Sub-tarea sin nombre', // Default text
                completed: typeof sub.completed === 'boolean' ? sub.completed : false // Ensure boolean
            })) : [], // Ensure subtasks is an array and clean its items
            showSubtaskUI: typeof todo.showSubtaskUI === 'boolean' ? todo.showSubtaskUI : false, // Ensure boolean with default false
            priorityColor: PRIORITY_COLORS.includes(todo.priorityColor) ? todo.priorityColor : 'none', // Ensure valid color with default 'none'
            date: typeof todo.date === 'string' && todo.date.match(/^\d{4}-\d{2}-\d{2}$/) ? todo.date : null // Add date property, validate format
        }));

        return cleanedTodos;

    } catch (e) {
        console.error("Error loading todos from Firestore:", e);
        // Fallback: if Firestore load fails, try loading from localStorage
        console.warn("Firestore load failed, attempting to load from localStorage as fallback...");
        const fallbackTodos = loadTodos(); // Use the original loadTodos function
         if (fallbackTodos.length > 0) {
             alert("No se pudieron cargar los datos de la nube. Usando datos locales.");
         } else {
              alert("No se pudieron cargar los datos de la nube ni datos locales. Empezando con lista vacía.");
         }
        return fallbackTodos; // Return data from localStorage
    }
  }

  // 6. Al cargar la página, traer las tareas desde Firestore (o Local Storage como fallback)
  // This replaces the original DOMContentLoaded logic for loading data.
  window.addEventListener('DOMContentLoaded', async () => {
      console.log("Module script DOMContentLoaded. Loading from Firestore...");
      // Keep the dark mode check here as it's fast and doesn't depend on todo data
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
          window.enableDarkMode(); // Use the global function
      } else {
          window.disableDarkMode(); // Use the global function
      }

      const todos = await loadTodosOnline(); // Wait for Firebase load (with localStorage fallback)
      window.renderTodos(todos); // Use the global renderTodos function
       console.log("Initial render complete.");
  });


  // 7. Sobrescribir tu función original de guardado para que también use Firestore
  // Use window.saveTodos to make sure we overwrite the global function used everywhere.
  window.saveTodos = function(todosArray) {
    // First, save to localStorage immediately (synchronous)
    try {
        localStorage.setItem('todos', JSON.stringify(todosArray));
         console.log("Saved todos to localStorage.");
    } catch (e) {
        console.error("Error saving to localStorage:", e);
    }

    // Then, save to Firestore (asynchronous)
    // We don't need to await this here, it can happen in the background.
    saveTodosOnline(todosArray);
  };

  // Expose loadTodosOnline globally if needed elsewhere (optional)
  // window.loadTodosOnline = loadTodosOnline;

</script>
